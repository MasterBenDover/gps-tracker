<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<title>GPS Tracker — Modern Glass</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>

<style>
:root {
  --bg: #0b0f14;
  --panel: rgba(255,255,255,0.05);
  --muted: #9aa7b2;
  --accent: #6a0dad;
  --green: #00ff55;
  --glass: rgba(255, 255, 255, 0.1);
  --btn-hover: rgba(255, 255, 255, 0.15);
}

html, body {
  margin:0; padding:0; height:100%;
  font-family:'Inter',sans-serif;
  background:var(--bg); color:#e6eef6;
}

#map { position: fixed; inset:0; }

/* ---- TOPBAR ---- */
.topbar {
  position: absolute; top:12px; left:12px; z-index:999;
  background: var(--panel); border-radius:20px; padding:16px;
  display:flex; gap:14px; flex-wrap:wrap;
  backdrop-filter: blur(20px) saturate(180%);
  box-shadow: 0 16px 40px rgba(0,0,0,0.7);
}

.topbar button, .topbar input, .topbar select {
  background: var(--glass);
  border:none; color:#e6eef6;
  padding:12px 18px;
  border-radius:14px;
  font-size:14px;
  cursor:pointer;
  position: relative;
  overflow: hidden;
  transition: all 0.35s cubic-bezier(0.4,0,0.2,1);
}

.topbar button:hover {
  background: var(--btn-hover);
  transform: translateY(-2px);
}

@keyframes pulseTap {
  0% { transform: scale(1); }
  50% { transform: scale(0.96); }
  100% { transform: scale(1); }
}
.topbar button:active { animation: pulseTap 0.25s ease-out; }

.topbar button::after {
  content: "";
  position: absolute;
  top: 0;
  left: -120%;
  width: 80%;
  height: 100%;
  background: linear-gradient(120deg,
    transparent 30%,
    rgba(255,255,255,0.15) 50%,
    transparent 70%
  );
  transform: skewX(-25deg);
  transition: all 0.7s ease;
}
.topbar button:hover::after { left: 120%; }

/* ---- TOAST ---- */
#notifyContainer {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column;
  gap: 12px;
  z-index: 99999;
  pointer-events: none;
}
.notifyToast {
  min-width: 180px;
  text-align: center;
  padding: 12px 18px;
  border-radius: 16px;
  background: rgba(255,255,255,0.08);
  backdrop-filter: blur(18px) saturate(160%);
  color: #fff;
  font-size: 14px;
  opacity: 0;
  transform: translateY(15px);
  transition:
    opacity 0.6s cubic-bezier(0.25, 0.1, 0.25, 1),
    transform 0.6s cubic-bezier(0.25, 0.1, 0.25, 1);
}
.notifyToast.show { opacity:1; transform:translateY(0); }
.notifyToast.hide { opacity:0; transform:translateY(20px); }

</style>
</head>

<body>

<div id="map"></div>
<div id="notifyContainer"></div>

<div class="topbar">
  <button id="startBtn">Starta inspelning</button>
  <button id="stopBtn" disabled>Stoppa inspelning</button>
  <input id="routeName" placeholder="Namn på rutt" />
  <button id="saveBtn" disabled>Spara Rutt</button>
  <button id="setTokenBtn">Token</button>
  <select id="routeSelect"></select>
  <button id="loadBtn">Ladda rutt</button>
  <button id="resetProgressBtn">Reset progress</button>
  <button id="followBtn">Följ: På</button>
</div>

<script>
(() => {

  /* -------------------------
     Utils & Notifier
     ------------------------- */
  const notify = msg => {
    const c = document.getElementById("notifyContainer");
    const t = document.createElement("div");
    t.className="notifyToast"; t.textContent=msg;
    c.appendChild(t);
    void t.offsetWidth;
    t.classList.add("show");
    setTimeout(()=>{ t.classList.remove("show"); t.classList.add("hide");
      setTimeout(()=>t.remove(),600);
    },2000);
  };

  const CFG={owner:'MasterBenDover',repo:'gps-tracker',folder:'routes'};
  const S={
    pat:sessionStorage.getItem('gh_pat')||null,
    rec:false,
    watchId:null,
    liveWatch:null,
    autoFollow:true,
    currentPoints:[],
    loaded:null, loadedPath:null,
    segments:[], completed:[],
    // smooth state
    smoothPos:{lat:null,lon:null},
    prevRawPos:null,
    headingRaw:0,
    headingSmooth:0
  };

  const $=id=>document.getElementById(id);
  const UI={
    start:$('startBtn'), stop:$('stopBtn'), save:$('saveBtn'),
    setToken:$('setTokenBtn'), select:$('routeSelect'),
    load:$('loadBtn'), name:$('routeName'),
    reset:$('resetProgressBtn'), follow:$('followBtn')
  };

  const b64={enc:s=>btoa(unescape(encodeURIComponent(s))), dec:b=>decodeURIComponent(escape(atob(b)))};

  const toRad = d => d * Math.PI/180;
  const hav = (a,b) => {
    const R=6371000;
    const dLat = toRad(b.lat - a.lat);
    const dLon = toRad(b.lon - a.lon);
    const la1 = toRad(a.lat), la2 = toRad(b.lat);
    const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(h));
  };

  /* -------------------------
     GitHub helper
     ------------------------- */
  const gh=async(p,m='GET',body=null)=>{
    const h={Accept:'application/vnd.github.v3+json'};
    if(S.pat) h.Authorization='token '+S.pat;
    if(body) h['Content-Type']='application/json';
    const r=await fetch(`https://api.github.com${p}`,{method:m,headers:h,body: body ? JSON.stringify(body) : undefined});
    if(!r.ok) throw new Error(await r.text());
    return r.json().catch(()=>null);
  };

  /* -------------------------
     Map init
     ------------------------- */
  const map = new maplibregl.Map({
    container:'map',
    style:{
      version:8,
      sources:{
        basemap:{type:'raster',tiles:[
          'https://basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png'
        ],tileSize:512}
      },
      layers:[{id:'osm',type:'raster',source:'basemap'}]
    },
    center:[18.06,59.33],
    zoom:13
  });

  map.on('load',()=>{

    /* Blue arrow SVG with soft shadow */
    const svgArrow = `
      <svg width="42" height="42" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="1.6" stdDeviation="2.2" flood-color="rgba(0,0,0,0.55)" />
          </filter>
        </defs>
        <path d="M12 2 L16 14 L12 12 L8 14 Z" fill="#007bff" filter="url(#shadow)"/>
      </svg>
    `;
    const img = new Image();
    img.src = 'data:image/svg+xml;base64,' + btoa(svgArrow);
    img.onload = () => map.addImage('gps-arrow', img, { pixelRatio: 2 });

    // Add data sources
    map.addSource('full',{type:'geojson',data:fc([])});
    map.addSource('seg',{type:'geojson',data:fc([])});
    map.addSource('trail',{type:'geojson',data:fc([])});
    map.addSource('gps',{type:'geojson',data:point(18.06,59.33,0)});

    // Layers
    map.addLayer({id:'full-line',type:'line',source:'full',paint:{'line-color':'#6A0DAD','line-width':4}});
    map.addLayer({id:'seg-line',type:'line',source:'seg',paint:{'line-color':['get','color'],'line-width':6}});
    map.addLayer({id:'trail-line',type:'line',source:'trail',paint:{'line-color':'#00ff55','line-width':6}});

    // GPS arrow symbol layer
    map.addLayer({
      id:'gps-arrow-layer',
      type:'symbol',
      source:'gps',
      layout:{
        'icon-image':'gps-arrow',
        'icon-size':1.6, // larger
        'icon-rotate':['get','heading'],
        'icon-rotation-alignment':'map',
        'icon-allow-overlap': true
      }
    });

    loadList();
  });

  /* small geo helpers */
  function fc(feats){ return { type:'FeatureCollection', features:feats }; }
  function point(lon,lat,heading){
    return fc([{
      type:'Feature',
      geometry:{type:'Point',coordinates:[lon,lat]},
      properties:{heading}
    }]);
  }
  function setGeo(id,data){ try{ map.getSource(id).setData(data); }catch(e){} }

  /* -------------------------
     Route list
     ------------------------- */
  async function loadList(){
    UI.select.innerHTML = '<option>(läser...)</option>';
    try{
      const d = await gh(`/repos/${CFG.owner}/${CFG.repo}/contents/${CFG.folder}`);
      UI.select.innerHTML = '<option value="">Välj rutt</option>';
      d.sort((a,b)=>b.name.localeCompare(a.name)).forEach(f=>{
        const o = document.createElement('option');
        o.value = f.path;
        o.textContent = f.name.replace(/\.json$/,'');
        UI.select.appendChild(o);
      });
    }catch(e){
      UI.select.innerHTML = '<option>(tom)</option>';
    }
  }

  /* -------------------------
     Recording controls
     ------------------------- */
  UI.start.onclick = () => {
    if(!navigator.geolocation) return alert('Ingen GPS');
    S.rec = true;
    S.currentPoints = [];
    UI.start.disabled = true;
    UI.stop.disabled = false;
    UI.save.disabled = true;
    setGeo('full', fc([]));
    setGeo('trail', fc([]));
    notify("Inspelning startad");

    S.watchId = navigator.geolocation.watchPosition(p=>{
      const pt = { lat:p.coords.latitude, lon:p.coords.longitude, t:p.timestamp||Date.now() };
      S.currentPoints.push(pt);
      drawFull();
      drawTrail();
      // When recording we still keep marker following if autoFollow
      if(S.autoFollow){
        // Use smooth movement to center (don't jump)
        if(S.smoothPos.lat != null && S.smoothPos.lon != null){
          map.easeTo({ center:[S.smoothPos.lon,S.smoothPos.lat], duration: 300 });
        } else {
          map.easeTo({ center:[pt.lon,pt.lat], duration: 300 });
        }
      }
    }, err => console.warn(err), { enableHighAccuracy:true, maximumAge:0 });
  };

  UI.stop.onclick = () => {
    if(S.watchId) navigator.geolocation.clearWatch(S.watchId);
    S.rec = false;
    UI.start.disabled = false;
    UI.stop.disabled = true;
    UI.save.disabled = S.currentPoints.length < 2;
    notify("Inspelning stoppad");
  };

  function drawFull(){
    setGeo('full', fc([{
      type:'Feature',
      geometry:{ type:'LineString', coordinates: S.currentPoints.map(p=>[p.lon,p.lat]) }
    }]));
  }

  function drawTrail(){
    const pts = S.currentPoints;
    if(pts.length < 2) return setGeo('trail', fc([]));
    setGeo('trail', fc([{
      type:'Feature',
      geometry:{ type:'LineString', coordinates: pts.slice(-2).map(p=>[p.lon,p.lat]) }
    }]));
  }

  /* -------------------------
     Token & load/save
     ------------------------- */
  UI.setToken.onclick = () => {
    const t = prompt('Klistra in din GitHub-token:');
    if(!t) return;
    S.pat = t.trim();
    sessionStorage.setItem('gh_pat', S.pat);
    notify("Token uppdaterad");
  };

  UI.load.onclick = async () => {
    if(!UI.select.value) return alert('Välj rutt');
    try{
      const f = await gh(`/repos/${CFG.owner}/${CFG.repo}/contents/${UI.select.value}`);
      S.loaded = JSON.parse(b64.dec(f.content));
      S.loadedPath = UI.select.value;
      buildSeg(S.loaded.points);
      zoomToRoute(S.loaded.points);
      notify("Rutt laddad");
    }catch(e){ alert('Fel: '+e); }
  };

  // saveBtn may be wired later; keep placeholder behavior
  UI.save.onclick = () => {
    notify("Spara ej implementerat i denna demo");
  };

  /* -------------------------
     Segment handling
     ------------------------- */
  function buildSeg(pts){
    S.segments = [];
    S.completed = [];
    for(let i=0;i<pts.length-1;i++){
      const a = pts[i], b = pts[i+1];
      S.segments.push({ a,b, coords:[[a.lon,a.lat],[b.lon,b.lat]] });
      S.completed.push(false);
    }
    drawSegGradient();
  }

  function gradientColor(p){
    const r1=106,g1=13,b1=173;
    const r2=0,g2=255,b2=85;
    return `rgb(${Math.round(r1+(r2-r1)*p)},${Math.round(g1+(g2-g1)*p)},${Math.round(b1+(b2-b1)*p)})`;
  }

  function drawSegGradient(){
    const feats = S.segments.map((s,i)=>{
      const pct = S.completed.slice(0,i+1).filter(x=>x).length / S.segments.length || 0;
      return { type:'Feature', geometry:{type:'LineString', coordinates: s.coords}, properties:{ color: gradientColor(pct) } };
    });
    setGeo('seg', fc(feats));
    // Optional: animate by briefly toggling opacity (soft effect)
    try {
      map.setPaintProperty('seg-line', 'line-opacity', 0.99);
      setTimeout(()=> map.setPaintProperty('seg-line', 'line-opacity', 1), 240);
    } catch(e){}
  }

  UI.reset.onclick = () => {
    S.completed = S.completed.map(()=>false);
    drawSegGradient();
    notify("Progress återställd");
  };

  UI.follow.onclick = () => {
    S.autoFollow = !S.autoFollow;
    UI.follow.textContent = S.autoFollow ? 'Följ: På' : 'Följ: Av';
    if(S.autoFollow){
      notify("Följer: På");
      // small zoom-in for effect
      map.easeTo({ zoom: Math.min(map.getZoom()+0.25, map.getMaxZoom()), duration: 420 });
    } else {
      notify("Följer: Av");
      map.easeTo({ zoom: Math.max(map.getZoom()-0.25, 0), duration: 420 });
    }
  };

  /* -------------------------
     Smooth helpers (C - hybrid)
     ------------------------- */

  // Exponential smoothing for scalar values
  function smoothValue(current, target, smoothing = 0.12) {
    if (current == null) return target;
    return current + (target - current) * smoothing;
  }

  // Smooth angle with shortest rotation
  function smoothAngle(current, target, smoothing = 0.15) {
    if (current == null) return target;
    let diff = target - current;
    diff = ((diff + 540) % 360) - 180; // shortest direction
    return (current + diff * smoothing + 360) % 360;
  }

  function headingBetween(a,b){
    const y = Math.sin((b.lon-a.lon) * Math.PI/180) * Math.cos(b.lat * Math.PI/180);
    const x = Math.cos(a.lat * Math.PI/180) * Math.sin(b.lat * Math.PI/180)
            - Math.sin(a.lat * Math.PI/180) * Math.cos(b.lat * Math.PI/180) * Math.cos((b.lon-a.lon) * Math.PI/180);
    return (Math.atan2(y,x) * 180/Math.PI + 360) % 360;
  }

  /* -------------------------
     Live GPS handler (smooth pos & smooth heading) + segment progress update
     ------------------------- */
  function handleLivePosition(pos){
    const raw = { lat: pos.coords.latitude, lon: pos.coords.longitude, t: pos.timestamp || Date.now() };

    // Smooth position
    S.smoothPos.lat = smoothValue(S.smoothPos.lat, raw.lat, 0.15);
    S.smoothPos.lon = smoothValue(S.smoothPos.lon, raw.lon, 0.15);

    // Heading raw: if prevRawPos exists, compute heading between prevRawPos and raw
    if(S.prevRawPos){
      S.headingRaw = headingBetween(S.prevRawPos, raw);
    }
    S.prevRawPos = raw;

    // Smooth heading
    S.headingSmooth = smoothAngle(S.headingSmooth, S.headingRaw, 0.18);

    // Update GPS marker (smoothed pos + smoothed heading)
    try{
      map.getSource('gps').setData(point(S.smoothPos.lon, S.smoothPos.lat, S.headingSmooth));
    }catch(e){ /* source may not be ready yet */ }

    // Auto-follow center
    if(S.autoFollow){
      map.easeTo({ center: [S.smoothPos.lon, S.smoothPos.lat], duration: 260 });
    }

    // Update segment progress: check distance to each segment's end point b
    if(S.segments && S.segments.length){
      let best=-1, dist=Infinity;
      S.segments.forEach((s,i)=>{
        const d = hav({lat:S.smoothPos.lat, lon:S.smoothPos.lon}, s.b);
        if(d < dist){ dist = d; best = i; }
      });
      // If within 25 meters of a segment endpoint mark that segment as completed
      if(best !== -1 && dist < 25){
        if(!S.completed[best]){
          S.completed[best] = true;
          drawSegGradient();
        }
      }
    }
  }

  // Start watching live position
  if(navigator.geolocation){
    S.liveWatch = navigator.geolocation.watchPosition(
      handleLivePosition,
      err => console.warn(err),
      { enableHighAccuracy:true, maximumAge:0, timeout:10000 }
    );
  }

  /* -------------------------
     Utilities: zoom to route
     ------------------------- */
  function zoomToRoute(pts){
    const lons = pts.map(p=>p.lon), lats = pts.map(p=>p.lat);
    const bounds = [
      [Math.min(...lons), Math.min(...lats)],
      [Math.max(...lons), Math.max(...lats)]
    ];
    try{ map.fitBounds(bounds, { padding:50, duration:800 }); } catch(e){}
  }

  /* -------------------------
     End
     ------------------------- */

})();
</script>
</body>
</html>