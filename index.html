<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<title>GPS Tracker — Modern Glass</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>

<style>
:root{
  --bg:#0b0f14;
  --panel:rgba(255,255,255,0.05);
  --muted:#9aa7b2;
  --accent:#007bff;
  --glass:rgba(255,255,255,0.1);
  --btn-hover:rgba(255,255,255,0.15);
}
html,body{height:100%;margin:0;padding:0;font-family:'Inter',sans-serif;background:var(--bg);color:#e6eef6;}
#map{position:fixed;inset:0;}

/* Topbar */
.topbar{
  position:absolute; top:12px; left:12px; z-index:999;
  background:var(--panel); border-radius:20px; padding:12px;
  display:flex; gap:10px; flex-wrap:wrap; align-items:center;
  backdrop-filter: blur(20px) saturate(180%);
  box-shadow: 0 16px 40px rgba(0,0,0,0.7);
  transition: all .28s ease;
}
.topbar.hidden{ opacity:0; transform:translateY(-12px); pointer-events:none; }
.topbar button, .topbar input, .topbar select{
  background:var(--glass); border:none; color:#e6eef6;
  padding:10px 14px; border-radius:12px; font-size:14px; cursor:pointer;
  transition: all .22s cubic-bezier(.4,0,.2,1);
}
.topbar button:hover{ background:var(--btn-hover); transform:translateY(-2px); }

/* Toggle */
.toggleTopbar{
  position:absolute; top:12px; right:12px; z-index:1000;
  width:44px; height:44px; border-radius:12px; border:none;
  background: rgba(255,255,255,0.08); color:#e6eef6; font-size:20px;
  cursor:pointer; backdrop-filter: blur(12px);
}
.toggleTopbar:hover{ background: rgba(255,255,255,0.12); }

/* Toast */
#notifyContainer{ position:fixed; bottom:28px; left:50%; transform:translateX(-50%); display:flex; flex-direction:column; gap:10px; z-index:99999; pointer-events:none; }
.notifyToast{ min-width:160px; text-align:center; padding:10px 14px; border-radius:12px; background: rgba(255,255,255,0.08); backdrop-filter: blur(14px) saturate(140%); color:#fff; font-size:14px; opacity:0; transform:translateY(10px); transition: opacity .45s cubic-bezier(.25,.1,.25,1), transform .45s cubic-bezier(.25,.1,.25,1); }
.notifyToast.show{ opacity:1; transform:translateY(0); }
.notifyToast.hide{ opacity:0; transform:translateY(18px); }

/* small responsive */
@media (max-width:700px){ .topbar{ left:8px; right:8px; } .topbar input, .topbar select{ min-width:120px; } }
</style>
</head>
<body>

<div id="map" aria-hidden="true"></div>
<div id="notifyContainer" aria-live="polite"></div>

<div class="topbar" role="region" aria-label="Controls">
  <button id="startBtn">Starta inspelning</button>
  <button id="stopBtn" disabled>Stoppa inspelning</button>
  <input id="routeName" placeholder="Namn på rutt" style="min-width:160px" />
  <button id="saveBtn" disabled>Spara Rutt</button>
  <button id="setTokenBtn">Token</button>
  <select id="routeSelect" style="min-width:160px"></select>
  <button id="loadBtn">Ladda rutt</button>
  <button id="resetProgressBtn">Reset progress</button>
  <button id="followBtn">Följ: Av</button>
</div>

<button id="toggleTopbar" class="toggleTopbar" title="Visa/Göm kontroller">≡</button>

<script>
(() => {
  // ---------- CONFIG (single repo) ----------
  const CFG = { owner: 'MasterBenDover', repo: 'gps-tracker', folder: 'routes', branch: 'main' };

  // ---------- NOTIFIER ----------
  const notify = (msg, ms = 2000) => {
    const c = document.getElementById('notifyContainer');
    const t = document.createElement('div'); t.className = 'notifyToast'; t.textContent = msg;
    c.appendChild(t); void t.offsetWidth; t.classList.add('show');
    setTimeout(()=>{ t.classList.remove('show'); t.classList.add('hide'); setTimeout(()=>t.remove(),300); }, ms);
  };

  // ---------- STATE ----------
  const S = {
    pat: sessionStorage.getItem('gh_pat') || null,
    rec: false,
    watchId: null,
    liveWatch: null,
    autoFollow: false,
    currentPoints: [],
    loaded: null,
    loadedPath: null,
    segments: [],
    completed: [],
    // smoothing
    smoothPos: { lat: null, lon: null },
    prevRawPos: null,
    headingRaw: 0,
    headingSmooth: 0
  };

  const $ = id => document.getElementById(id);
  const UI = {
    start: $('startBtn'), stop: $('stopBtn'), save: $('saveBtn'),
    setToken: $('setTokenBtn'), select: $('routeSelect'),
    load: $('loadBtn'), name: $('routeName'),
    reset: $('resetProgressBtn'), follow: $('followBtn'),
    toggle: $('toggleTopbar')
  };

  // ---------- helpers ----------
  const b64enc = s => btoa(unescape(encodeURIComponent(s)));
  const b64dec = b => decodeURIComponent(escape(atob(b)));
  const toRad = d => d * Math.PI/180;
  const hav = (a,b) => {
    const R=6371000;
    const dLat = toRad(b.lat-a.lat), dLon = toRad(b.lon-a.lon);
    const la1 = toRad(a.lat), la2 = toRad(b.lat);
    const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(h));
  };

  // ---------- GitHub helper ----------
  async function gh(path, method='GET', body=null){
    const headers = { Accept: 'application/vnd.github.v3+json' };
    if (S.pat) headers['Authorization'] = 'token ' + S.pat;
    if (body) headers['Content-Type'] = 'application/json';
    const res = await fetch(`https://api.github.com${path}`, { method, headers, body: body ? JSON.stringify(body) : undefined });
    if (!res.ok) {
      const txt = await res.text();
      throw new Error(txt || res.statusText);
    }
    return res.json().catch(()=>null);
  }

  // ---------- MAP ----------
  const map = new maplibregl.Map({
    container:'map',
    style:{
      version:8,
      sources:{ basemap:{ type:'raster', tiles:['https://basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png'], tileSize:512 } },
      layers:[{ id:'osm', type:'raster', source:'basemap' }]
    },
    center:[18.06,59.33],
    zoom: 15,
    pitch: 0,
    bearing: 0
  });

  // Add layers & images when map loads
  map.on('load', () => {
    // create sources first for safety (gps source will be replaced when image is ready)
    map.addSource('full', { type:'geojson', data: fc([]) });
    map.addSource('seg', { type:'geojson', data: fc([]) });
    map.addSource('trail', { type:'geojson', data: fc([]) });
    // add a placeholder gps source; we'll update it later and/or replace after image loaded
    map.addSource('gps', { type:'geojson', data: point(18.06,59.33,0) });

    // base layers
    map.addLayer({ id:'full-line', type:'line', source:'full', paint:{ 'line-color':'#6A0DAD', 'line-width':4 } });
    map.addLayer({ id:'seg-line', type:'line', source:'seg', paint:{ 'line-color':['get','color'], 'line-width':6 } });
    map.addLayer({ id:'trail-line', type:'line', source:'trail', paint:{ 'line-color':'#00ff55', 'line-width':6 } });

    // create SVG for arrow (no outline, small shadow)
    const svg = `
      <svg width="48" height="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <filter id="ds" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="2" stdDeviation="2" flood-color="rgba(0,0,0,0.6)"/>
          </filter>
        </defs>
        <path d="M12 2 L17 15 L12 13 L7 15 Z" fill="#007bff" filter="url(#ds)"/>
      </svg>`;
    const img = new Image();
    img.onload = () => {
      try {
        map.addImage('gps-arrow', img, { pixelRatio: 2 });
      } catch(e){ /* ignore if already added */ }

      // add the symbol layer that uses the image
      if (!map.getLayer('gps-arrow-layer')) {
        map.addLayer({
          id: 'gps-arrow-layer',
          type: 'symbol',
          source: 'gps',
          layout: {
            'icon-image': 'gps-arrow',
            'icon-size': 2.0, // larger
            'icon-rotate': ['get','heading'],
            'icon-rotation-alignment': 'map',
            'icon-allow-overlap': true
          }
        });
      }
    };
    img.src = 'data:image/svg+xml;base64,' + btoa(svg);

    // load list after map ready
    loadList();
  });

  // ---------- geo helpers ----------
  function fc(feats){ return { type:'FeatureCollection', features: feats }; }
  function point(lon,lat,heading){ return fc([{ type:'Feature', geometry:{ type:'Point', coordinates:[lon,lat] }, properties:{ heading } }]); }
  function setGeo(id,data){ try{ map.getSource(id).setData(data); }catch(e){ /*ignore*/ } }

  // ---------- Remember permission (ask once) ----------
  (function rememberPermission(){
    if (localStorage.getItem('gps_allowed') === '1') return;
    navigator.geolocation.getCurrentPosition(
      () => localStorage.setItem('gps_allowed','1'),
      () => localStorage.setItem('gps_allowed','0'),
      { enableHighAccuracy:true }
    );
  })();

  // ---------- Route list ----------
  async function loadList(){
    UI.select.innerHTML = '<option>(läser...)</option>';
    try {
      const files = await gh(`/repos/${CFG.owner}/${CFG.repo}/contents/${CFG.folder}`);
      UI.select.innerHTML = '<option value="">Välj rutt</option>';
      files.sort((a,b)=>b.name.localeCompare(a.name)).forEach(f=>{
        const o = document.createElement('option'); o.value = f.path; o.textContent = f.name.replace(/\.json$/,''); UI.select.appendChild(o);
      });
    } catch(e){
      UI.select.innerHTML = '<option>(tom)</option>';
    }
  }

  // ---------- Recording ----------
  UI.start.onclick = () => {
    if (!navigator.geolocation) return alert('Ingen GPS');
    S.rec = true; S.currentPoints = [];
    UI.start.disabled = true; UI.stop.disabled = false; UI.save.disabled = true;
    setGeo('full', fc([])); setGeo('trail', fc([]));
    notify('Inspelning startad');
    S.watchId = navigator.geolocation.watchPosition(p=>{
      const pt = { lat: p.coords.latitude, lon: p.coords.longitude, t: p.timestamp || Date.now() };
      S.currentPoints.push(pt);
      drawFull(); drawTrail();
      UI.save.disabled = S.currentPoints.length < 2;
      if (S.autoFollow && S.smoothPos.lat != null) {
        map.easeTo({ center:[S.smoothPos.lon, S.smoothPos.lat], duration:300, easing: t => t*t*(3-2*t) });
      } else if (S.autoFollow) {
        map.easeTo({ center:[pt.lon, pt.lat], duration:300, easing: t => t*t*(3-2*t) });
      }
    }, err => console.warn(err), { enableHighAccuracy:true, maximumAge:0 });
  };

  UI.stop.onclick = () => {
    if (S.watchId) navigator.geolocation.clearWatch(S.watchId);
    S.rec = false; UI.start.disabled = false; UI.stop.disabled = true;
    UI.save.disabled = S.currentPoints.length < 2;
    notify('Inspelning stoppad');
  };

  function drawFull(){
    setGeo('full', fc([ { type:'Feature', geometry:{ type:'LineString', coordinates: S.currentPoints.map(p=>[p.lon,p.lat]) } } ]));
  }
  function drawTrail(){
    const pts = S.currentPoints; if (pts.length < 2) return setGeo('trail', fc([]));
    setGeo('trail', fc([ { type:'Feature', geometry:{ type:'LineString', coordinates: pts.slice(-2).map(p=>[p.lon,p.lat]) } } ]));
  }

  // ---------- Token handling ----------
  UI.setToken.onclick = () => {
    const t = prompt('Klistra in din GitHub Personal Access Token (classic token med repo-scope):');
    if (!t) return;
    S.pat = t.trim(); sessionStorage.setItem('gh_pat', S.pat); notify('Token sparad i sessionStorage'); loadList();
  };

  // ---------- Save & Load routes ----------
  UI.save.onclick = async () => {
    if (S.currentPoints.length < 2) return notify('Minst 2 punkter krävs');
    const nameRaw = UI.name.value.trim();
    const name = nameRaw ? nameRaw : `route_${new Date().toISOString().replace(/[:.]/g,'-')}`;
    const path = `${CFG.folder}/${name}.json`;
    const bodyObj = { name, points: S.currentPoints };
    const content = b64enc(JSON.stringify(bodyObj, null, 2));
    try {
      let sha = null;
      try {
        const existing = await gh(`/repos/${CFG.owner}/${CFG.repo}/contents/${path}`);
        if (existing && existing.sha) sha = existing.sha;
      } catch(e){ /* not found -> create */ }

      const putBody = { message: sha ? `Uppdaterar rutt ${name}` : `Skapar rutt ${name}`, content, branch: CFG.branch };
      if (sha) putBody.sha = sha;
      await gh(`/repos/${CFG.owner}/${CFG.repo}/contents/${path}`, 'PUT', putBody);
      notify(sha ? 'Rutt uppdaterad' : 'Rutt sparad');
      await loadList();
    } catch(e){
      console.error(e);
      notify('Fel vid sparning — kontrollera PAT');
      alert('Fel vid sparning:\n' + (e.message || e));
    }
  };

  UI.load.onclick = async () => {
    if (!UI.select.value) return alert('Välj rutt');
    try {
      const f = await gh(`/repos/${CFG.owner}/${CFG.repo}/contents/${UI.select.value}`);
      const raw = JSON.parse(b64dec(f.content));
      S.loaded = raw; S.loadedPath = UI.select.value;
      buildSeg(raw.points); zoomToRoute(raw.points);
      notify('Rutt laddad');
    } catch(e){
      console.error(e); alert('Fel vid laddning: '+(e.message||e));
    }
  };

  // ---------- Segments ----------
  function buildSeg(pts){
    S.segments = []; S.completed = [];
    for (let i=0;i<pts.length-1;i++){
      const a = pts[i], b = pts[i+1];
      S.segments.push({ a,b, coords:[[a.lon,a.lat],[b.lon,b.lat]] });
      S.completed.push(false);
    }
    drawSegGradient();
  }
  function gradientColor(p){
    const r1=106,g1=13,b1=173, r2=0,g2=255,b2=85;
    return `rgb(${Math.round(r1+(r2-r1)*p)},${Math.round(g1+(g2-g1)*p)},${Math.round(b1+(b2-b1)*p)})`;
  }
  function drawSegGradient(){
    const feats = S.segments.map((s,i)=>{
      const pct = S.completed.slice(0,i+1).filter(x=>x).length / (S.segments.length || 1);
      return { type:'Feature', geometry:{ type:'LineString', coordinates: s.coords }, properties:{ color: gradientColor(pct) } };
    });
    setGeo('seg', fc(feats));
    try { map.setPaintProperty('seg-line','line-opacity',0.99); setTimeout(()=>map.setPaintProperty('seg-line','line-opacity',1),220); } catch(e){}
  }

  UI.reset.onclick = () => { S.completed = S.completed.map(()=>false); drawSegGradient(); notify('Progress återställd'); };

  // ---------- Follow toggle ----------
  UI.follow.onclick = () => {
    S.autoFollow = !S.autoFollow;
    UI.follow.textContent = S.autoFollow ? 'Följ: På' : 'Följ: Av';
    notify(S.autoFollow ? 'Följer: På' : 'Följer: Av');
    if (S.autoFollow && S.smoothPos.lat != null) {
      // center immediately and rotate map to current heading
      map.jumpTo({ center: [S.smoothPos.lon, S.smoothPos.lat], bearing: S.headingSmooth, pitch: 0 });
    }
  };

  // ---------- Smoothing helpers ----------
  function smoothValue(current, target, smoothing = 0.12){ if (current == null) return target; return current + (target - current) * smoothing; }
  function smoothAngle(current, target, smoothing = 0.15){ if (current == null) return target; let diff = target - current; diff = ((diff + 540) % 360) - 180; return (current + diff * smoothing + 360) % 360; }
  function headingBetween(a,b){
    const y = Math.sin((b.lon-a.lon)*Math.PI/180) * Math.cos(b.lat*Math.PI/180);
    const x = Math.cos(a.lat*Math.PI/180)*Math.sin(b.lat*Math.PI/180) -
              Math.sin(a.lat*Math.PI/180)*Math.cos(b.lat*Math.PI/180)*Math.cos((b.lon-a.lon)*Math.PI/180);
    return (Math.atan2(y,x)*180/Math.PI + 360) % 360;
  }

  // ---------- Live position handler (smoothing + heading + map rotation) ----------
  function handlePosition(pos){
    const raw = { lat: pos.coords.latitude, lon: pos.coords.longitude, t: pos.timestamp || Date.now() };

    // smooth position
    S.smoothPos.lat = smoothValue(S.smoothPos.lat, raw.lat, 0.15);
    S.smoothPos.lon = smoothValue(S.smoothPos.lon, raw.lon, 0.15);

    // raw heading (from prev raw pos)
    if (S.prevRawPos) S.headingRaw = headingBetween(S.prevRawPos, raw);
    S.prevRawPos = raw;

    // smooth heading
    S.headingSmooth = smoothAngle(S.headingSmooth, S.headingRaw, 0.18);

    // update gps source (smoothed)
    setGeo('gps', point(S.smoothPos.lon, S.smoothPos.lat, S.headingSmooth));

    // if recording: push raw into points (accurate)
    if (S.rec) {
      // during recording we already push in watchPosition handler; ensure save enabled
      UI.save.disabled = S.currentPoints.length < 2;
    }

    // auto-follow: smooth rotation + center
    if (S.autoFollow) {
      map.easeTo({
        center: [S.smoothPos.lon, S.smoothPos.lat],
        bearing: S.headingSmooth,
        duration: 300,
        easing: t => t*t*(3-2*t)
      });
    }

    // segments
    if (S.segments.length){
      let best=-1, dist=Infinity;
      S.segments.forEach((s,i)=>{
        const d = hav({ lat: S.smoothPos.lat, lon: S.smoothPos.lon }, s.b);
        if (d < dist){ dist = d; best = i; }
      });
      if (best !== -1 && dist < 25 && !S.completed[best]) { S.completed[best] = true; drawSegGradient(); }
    }
  }

  // start geo watch (we also used a separate watch when recording - keep one main)
  if (navigator.geolocation) {
    S.liveWatch = navigator.geolocation.watchPosition(
      (p) => {
        // Always update currentPoints when recording
        if (S.rec) {
          S.currentPoints.push({ lat: p.coords.latitude, lon: p.coords.longitude, t: p.timestamp || Date.now() });
          drawFull(); drawTrail();
          UI.save.disabled = S.currentPoints.length < 2;
        }
        // Use handlePosition for smoothing & map
        handlePosition(p);
      },
      err => console.warn(err),
      { enableHighAccuracy:true, maximumAge:0, timeout:10000 }
    );
  } else {
    notify('Geolocation ej tillgängligt');
  }

  // ---------- Zoom to route ----------
  function zoomToRoute(pts){
    const lons = pts.map(p=>p.lon), lats = pts.map(p=>p.lat);
    try { map.fitBounds([[Math.min(...lons), Math.min(...lats)], [Math.max(...lons), Math.max(...lats)]], { padding:50, duration:800 }); } catch(e){}
  }

  // ---------- Toggle topbar ----------
  UI.toggle.onclick = () => { document.querySelector('.topbar').classList.toggle('hidden'); UI.toggle.textContent = document.querySelector('.topbar').classList.contains('hidden') ? '▸' : '≡'; };

  // ---------- Utility decode content ----------
  function decodeContentSafe(b64){ try { return decodeURIComponent(escape(atob(b64))); } catch(e){ return atob(b64); } }

})();
</script>
</body>
</html>