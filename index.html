<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <title>GPS Tracker — MasterBenDover (Dark)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- MapLibre GL -->
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>

  <style>
    :root{
      --bg:#0a0e13;
      --panel:#12181f;
      --muted:#94a3b8;
      --accent:#8b5cf6;
      --accent-hover:#a78bfa;
      --green:#10b981;
      --green-hover:#34d399;
      --panel-border: rgba(139,92,246,0.1);
      --glass: rgba(139,92,246,0.05);
    }
    html,body{height:100%;margin:0;font-family:'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background:var(--bg);color:#f1f5f9}
    #map{position:fixed;inset:0;z-index:1;}
    
    .topbar{
      position: absolute; left:16px; top:16px; z-index: 999;
      background: rgba(18,24,31,0.95);
      backdrop-filter: blur(20px);
      border:1px solid var(--panel-border);
      padding:14px 16px; border-radius:16px; 
      box-shadow:0 8px 32px rgba(0,0,0,0.4), 0 0 0 1px rgba(139,92,246,0.05);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap; min-width:380px;
    }
    
    button,input,select{ 
      background:var(--glass); 
      border:1px solid rgba(139,92,246,0.15); 
      color:#f1f5f9; 
      padding:10px 16px; 
      border-radius:10px; 
      font-size:14px;
      font-weight:500;
      cursor:pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      position:relative;
      z-index:1;
    }
    
    button:hover:not(:disabled){
      background:rgba(139,92,246,0.12);
      border-color:rgba(139,92,246,0.3);
      transform:translateY(-1px);
      box-shadow:0 4px 12px rgba(139,92,246,0.2);
    }
    
    button:active:not(:disabled){
      transform:translateY(0) scale(0.98);
      box-shadow:0 2px 8px rgba(139,92,246,0.3);
    }
    
    @keyframes ripple {
      to {
        width: 300px;
        height: 300px;
        opacity: 0;
      }
    }
    
    button:disabled{
      opacity:0.4;
      cursor:not-allowed;
      transform:none;
    }
    
    input{
      min-width:160px;
      background:rgba(139,92,246,0.03);
      transition: all 0.2s ease;
    }
    
    input:focus{
      outline:none;
      border-color:var(--accent);
      background:rgba(139,92,246,0.08);
      box-shadow:0 0 0 3px rgba(139,92,246,0.1);
    }
    
    select{
      cursor:pointer;
    }
    
    select:hover{
      border-color:rgba(139,92,246,0.3);
    }
    
    .small{font-size:13px;padding:8px 14px}
    
    #instrPanel{
      position:absolute; right:16px; top:16px; z-index:999;
      width:340px; max-height:70vh; overflow:auto;
      background:rgba(18,24,31,0.95);
      backdrop-filter: blur(20px);
      border:1px solid var(--panel-border); 
      border-radius:16px; 
      padding:16px; 
      color:var(--muted);
      box-shadow:0 8px 32px rgba(0,0,0,0.4), 0 0 0 1px rgba(139,92,246,0.05);
    }
    
    .instrTitle{
      color:#fff;
      font-weight:600;
      font-size:16px;
      margin-bottom:12px;
      padding-bottom:12px;
      border-bottom:1px solid rgba(139,92,246,0.1);
    }
    
    .instrItem{
      padding:12px;
      border-bottom:1px solid rgba(139,92,246,0.05); 
      color:var(--muted);
      transition: background 0.2s ease;
      border-radius:8px;
      margin-bottom:4px;
    }
    
    .instrItem:hover{
      background:rgba(139,92,246,0.05);
    }
    
    .status{
      font-size:13px;
      color:var(--muted);
      margin-left:8px;
      padding:4px 10px;
      background:rgba(139,92,246,0.1);
      border-radius:6px;
    }
    
    .note{
      font-size:12px;
      color:#64748b;
      margin-top:12px;
      padding:10px;
      background:rgba(139,92,246,0.03);
      border-radius:8px;
      border-left:3px solid rgba(139,92,246,0.3);
    }
    
    #instrPanel::-webkit-scrollbar{
      width:8px;
    }
    
    #instrPanel::-webkit-scrollbar-track{
      background:rgba(139,92,246,0.03);
      border-radius:4px;
    }
    
    #instrPanel::-webkit-scrollbar-thumb{
      background:rgba(139,92,246,0.2);
      border-radius:4px;
    }
    
    #instrPanel::-webkit-scrollbar-thumb:hover{
      background:rgba(139,92,246,0.3);
    }
  </style>
</head>
<body>
  <div id="map" aria-hidden="true"></div>

  <div class="topbar" role="region" aria-label="Controls">
    <button id="startBtn" class="small">Starta inspelning</button>
    <button id="stopBtn" class="small" disabled>Stoppa inspelning</button>

    <label>
      <input id="routeName" placeholder="Namn på rutt" />
    </label>
    <button id="saveBtn" class="small" disabled>Spara rutt till GitHub</button>

    <button id="setTokenBtn" class="small">Sätt GitHub-token</button>
    <span id="tokenStatus" class="status">Token: (ej satt)</span>

    <label style="margin-left:8px">Välj rutt:
      <select id="routeSelect"></select>
    </label>
    <button id="loadBtn" class="small">Ladda rutt</button>

    <button id="resetProgressBtn" class="small" title="Reset progress för aktuell laddad rutt">Reset progress</button>
    <button id="followBtn" class="small">Följ: På</button>
  </div>

  <div id="instrPanel" role="region" aria-label="Turn-by-turn">
    <div class="instrTitle">Turn-by-turn & status</div>
    <div id="instrList" style="min-height:40px;color:var(--muted)">Ingen rutt vald</div>
    <div class="note">Gröna segment är permanent markerade under en session (sparas i din webbläsare). Ladda en rutt igen om du vill börja om.</div>
  </div>

<script>
/* KONFIGURATION */
const GITHUB_OWNER = 'MasterBenDover';
const GITHUB_REPO  = 'gps-tracker';
const ROUTES_FOLDER = 'routes';
const OSRM_BASE = 'https://router.project-osrm.org';

/* GLOBAL STATE */
let pat = sessionStorage.getItem('gh_pat') || null;
let recording = false;
let watchId = null;
let currentPoints = [];
let loadedRoute = null;
let loadedRoutePath = null;
let completedSegments = [];
let firstFixEstablished = false;
let liveWatchId = null;
let autoFollow = true;

/* MAPLIBRE INIT */
const map = new maplibregl.Map({
  container: 'map',
  style: {
    version: 8,
    sources: {
      'carto-dark': {
        type: 'raster',
        tiles: ['https://basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png'],
        tileSize: 512
      }
    },
    layers: [
      { id:'osm-dark', type:'raster', source:'carto-dark' }
    ]
  },
  center: [18.06,59.33],
  zoom: 13
});

map.addControl(new maplibregl.NavigationControl(), 'top-left');

/* UI REFS */
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const saveBtn = document.getElementById('saveBtn');
const setTokenBtn = document.getElementById('setTokenBtn');
const tokenStatus = document.getElementById('tokenStatus');
const routeSelect = document.getElementById('routeSelect');
const loadBtn = document.getElementById('loadBtn');
const instrList = document.getElementById('instrList');
const routeNameInput = document.getElementById('routeName');
const resetProgressBtn = document.getElementById('resetProgressBtn');
const followBtn = document.getElementById('followBtn');

updateTokenUI();

/* HELPERS */
function toBase64(str){ return btoa(unescape(encodeURIComponent(str))); }
function fromBase64(b64){ return decodeURIComponent(escape(atob(b64))); }

function haversine(a,b){
  const R=6371000;
  const toRad = d => d*Math.PI/180;
  const dLat=toRad(b.lat-a.lat), dLon=toRad(b.lon-a.lon);
  const lat1=toRad(a.lat), lat2=toRad(b.lat);
  const sinDlat=Math.sin(dLat/2), sinDlon=Math.sin(dLon/2);
  const c=2*Math.asin(Math.sqrt(sinDlat*sinDlat + Math.cos(lat1)*Math.cos(lat2)*sinDlon*sinDlon));
  return R*c;
}

function createRipple(e) {
  const button = e.currentTarget;
  const ripple = document.createElement('span');
  const rect = button.getBoundingClientRect();
  const size = Math.max(rect.width, rect.height);
  const x = e.clientX - rect.left - size / 2;
  const y = e.clientY - rect.top - size / 2;
  
  ripple.style.cssText = `
    position: absolute;
    width: ${size}px;
    height: ${size}px;
    left: ${x}px;
    top: ${y}px;
    background: rgba(139,92,246,0.4);
    border-radius: 50%;
    pointer-events: none;
    animation: ripple 0.6s ease-out;
  `;
  
  button.appendChild(ripple);
  setTimeout(() => ripple.remove(), 600);
}

document.querySelectorAll('button').forEach(btn => {
  btn.addEventListener('click', createRipple);
});

/* VECTOR LAYERS */
map.on('load', () => {
  map.addSource('full-route', { type:'geojson', data: { type:'FeatureCollection', features:[] } });
  map.addLayer({ id:'full-route-line', type:'line', source:'full-route',
    paint: { 'line-color': '#8b5cf6', 'line-width': 4, 'line-opacity': 0.95 }
  });

  map.addSource('segments', { type:'geojson', data: { type:'FeatureCollection', features:[] } });
  map.addLayer({ id:'segments-line', type:'line', source:'segments',
    paint: { 'line-color': ['get','color'], 'line-width': 6, 'line-opacity': 1 }
  });

  map.addSource('trailer', { type:'geojson', data: { type:'FeatureCollection', features:[] } });
  map.addLayer({ id:'trailer-line', type:'line', source:'trailer',
    paint:{ 'line-color':'#10b981','line-width':6,'line-opacity':1 }
  });

  listSavedRoutes();
});

/* START / STOP RECORDING */
startBtn.addEventListener('click', () => {
  if (!('geolocation' in navigator)) { 
    alert('Geolocation stöds inte i din webbläsare.'); 
    return; 
  }
  recording = true;
  currentPoints = [];
  updateFullRouteOnMap([]);
  updateTrailer([]);
  updateSegmentsOnMap([]);
  startBtn.disabled = true; 
  stopBtn.disabled = false; 
  saveBtn.disabled = true;
  routeNameInput.value = routeNameInput.value || '';

  watchId = navigator.geolocation.watchPosition(pos => {
    const pt = { 
      lat: pos.coords.latitude, 
      lon: pos.coords.longitude, 
      timestamp: pos.timestamp || Date.now() 
    };
    currentPoints.push(pt);
    updateFullRouteOnMap(currentPoints);
    
    if (currentPoints.length > 1) {
      updateTrailer([currentPoints[currentPoints.length-2], currentPoints[currentPoints.length-1]]);
    }
    if (autoFollow) {
      map.easeTo({ center: [pt.lon, pt.lat], duration: 300 });
    }
  }, err => console.error('watchPosition err', err), 
  { enableHighAccuracy:true, maximumAge:0, timeout:10000 });
});

stopBtn.addEventListener('click', () => {
  if (watchId !== null) navigator.geolocation.clearWatch(watchId);
  watchId = null; 
  recording = false;
  startBtn.disabled = false; 
  stopBtn.disabled = true;
  saveBtn.disabled = currentPoints.length < 2;
  alert('Inspelning stoppad. Punkter: ' + currentPoints.length);
});

/* UPDATE MAP SOURCES */
function updateFullRouteOnMap(points){
  const coords = points.map(p => [p.lon, p.lat]);
  const geo = { 
    type:'FeatureCollection', 
    features: coords.length > 0 ? [{ 
      type:'Feature', 
      geometry:{ type:'LineString', coordinates: coords }, 
      properties:{} 
    }] : []
  };
  const src = map.getSource('full-route');
  if (src) src.setData(geo);
}

function updateSegmentsOnMap(segFeatures){
  const geo = { type:'FeatureCollection', features: segFeatures };
  const src = map.getSource('segments');
  if (src) src.setData(geo);
}

function updateTrailer(points){
  if (!points || points.length < 2) {
    const src = map.getSource('trailer'); 
    if (src) src.setData({ type:'FeatureCollection', features:[] }); 
    return;
  }
  const coords = points.map(p => [p.lon, p.lat]);
  const geo = { 
    type:'FeatureCollection', 
    features: [{ 
      type:'Feature', 
      geometry:{ type:'LineString', coordinates: coords }, 
      properties:{} 
    }]
  };
  const src = map.getSource('trailer'); 
  if (src) src.setData(geo);
}

/* GITHUB HELPERS */
function updateTokenUI(){ 
  tokenStatus.textContent = pat ? 'Token: satt' : 'Token: (ej satt)'; 
}

setTokenBtn.addEventListener('click', () => {
  const t = prompt('Klistra in din GitHub Personal Access Token:');
  if (!t) return;
  pat = t.trim();
  sessionStorage.setItem('gh_pat', pat);
  updateTokenUI();
});

async function ghApi(path, method='GET', body=null){
  const url = `https://api.github.com${path}`;
  const headers = { Accept:'application/vnd.github.v3+json' };
  if (pat) headers.Authorization = 'token ' + pat;
  if (body) headers['Content-Type'] = 'application/json';
  const res = await fetch(url, { 
    method, 
    headers, 
    body: body ? JSON.stringify(body) : undefined 
  });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(`GitHub API fel ${res.status}: ${txt}`);
  }
  return res.json().catch(()=>null);
}

/* LIST SAVED ROUTES */
async function listSavedRoutes(){
  routeSelect.innerHTML = '<option value="">(läser...)</option>';
  try {
    const path = `/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${ROUTES_FOLDER}`;
    const data = await ghApi(path);
    routeSelect.innerHTML = '<option value="">Välj rutt</option>';
    data.sort((a,b)=>b.name.localeCompare(a.name));
    data.forEach(f => {
      const opt = document.createElement('option');
      opt.value = f.path;
      opt.textContent = f.name.replace(/\.json$/,'');
      opt.dataset.sha = f.sha;
      routeSelect.appendChild(opt);
    });
  } catch (e) {
    console.warn('Could not list routes:', e);
    routeSelect.innerHTML = '<option value="">(ingen routes/ funnen)</option>';
  }
}

/* LOAD ROUTE */
async function loadRouteFromPath(path){
  try {
    const meta = await ghApi(`/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${path}`);
    const content = fromBase64(meta.content.replace(/\n/g,''));
    return JSON.parse(content);
  } catch (e) {
    alert('Kunde inte ladda rutt: ' + e.message);
    return null;
  }
}

/* SAVE ROUTE */
async function saveRouteToGitHub(name, points){
  if (!pat) { alert('Sätt GitHub-token först.'); return; }
  if (!name) { alert('Ange namn på rutten.'); return; }
  const safe = name.replace(/[^a-zA-Z0-9-_ ]/g,'').replace(/\s+/g,'_');
  const ts = Date.now();
  const path = `${ROUTES_FOLDER}/${safe}_${ts}.json`;
  const data = { name, created: ts, points };
  const content = toBase64(JSON.stringify(data, null, 2));
  const message = `Add route ${name} (${ts})`;
  try {
    await ghApi(`/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${path}`, 'PUT', {
      message, content, branch: 'main'
    });
    alert('Rutt sparad som ' + path);
    await listSavedRoutes();
  } catch (e) {
    alert('Kunde inte spara: ' + e.message);
  }
}

/* DRAW SEGMENTS */
function recomputeAndDrawSegments(){
  if (!loadedRoute || !loadedRoute.points || loadedRoute.points.length < 2) {
    updateSegmentsOnMap([]);
    return;
  }
  const pts = loadedRoute.points;
  const features = [];
  for (let i = 0; i < pts.length - 1; i++){
    const a = pts[i], b = pts[i+1];
    const color = completedSegments[i] ? '#10b981' : '#8b5cf6';
    features.push({
      type:'Feature',
      geometry: { type:'LineString', coordinates: [[a.lon,a.lat], [b.lon,b.lat]] },
      properties: { color }
    });
  }
  updateSegmentsOnMap(features);
}

/* STORAGE */
function storageKeyForRoute(path){
  return 'completedSegments_' + path;
}

function loadCompletedFromStorage(path){
  const key = storageKeyForRoute(path);
  const raw = localStorage.getItem(key);
  if (raw) {
    try { return JSON.parse(raw); } catch(e){ return []; }
  }
  return [];
}

function saveCompletedToStorage(path, arr){
  const key = storageKeyForRoute(path);
  localStorage.setItem(key, JSON.stringify(arr));
}

/* HANDLE LIVE POSITION */
function handleLivePosition(lat, lon){
  if (!loadedRoute || !loadedRoute.points || loadedRoute.points.length < 2) return;
  
  let bestIdx = 0, bestDist = Infinity;
  for (let i=0;i<loadedRoute.points.length;i++){
    const d = haversine({lat,lon}, loadedRoute.points[i]);
    if (d < bestDist){ bestDist = d; bestIdx = i; }
  }

  if (!firstFixEstablished){
    for (let i=0;i<bestIdx;i++) completedSegments[i] = true;
    firstFixEstablished = true;
  }

  if (bestIdx > 0) completedSegments[bestIdx - 1] = true;

  if (loadedRoutePath) saveCompletedToStorage(loadedRoutePath, completedSegments);

  recomputeAndDrawSegments();

  const matched = loadedRoute.points[bestIdx];
  updateTrailer([{ lat: matched.lat, lon: matched.lon }, { lat, lon }]);
}

/* LOAD BUTTON */
loadBtn.addEventListener('click', async () => {
  const sel = routeSelect.value;
  if (!sel) { alert('Välj en rutt först'); return; }
  const raw = await loadRouteFromPath(sel);
  if (!raw) return;
  loadedRoute = raw;
  loadedRoutePath = sel;

  const coords = loadedRoute.points.map(p => [p.lon,p.lat]);
  updateFullRouteOnMap(loadedRoute.points);
  map.fitBounds(coords, { padding:20 });

  updateTrailer([]);
  completedSegments = loadCompletedFromStorage(loadedRoutePath) || [];
  
  if (completedSegments.length < loadedRoute.points.length - 1) {
    const diff = (loadedRoute.points.length - 1) - completedSegments.length;
    for (let i=0;i<diff;i++) completedSegments.push(false);
  }
  firstFixEstablished = false;
  recomputeAndDrawSegments();

  try {
    const coordsStr = loadedRoute.points.map(p => `${p.lon},${p.lat}`).join(';');
    const url = `${OSRM_BASE}/route/v1/driving/${coordsStr}?steps=true&geometries=geojson&overview=full`;
    const r = await fetch(url);
    const data = await r.json();
    instrList.innerHTML = '';
    if (data.routes && data.routes.length){
      const steps = data.routes[0].legs.flatMap(l=>l.steps);
      steps.forEach((s,i)=>{
        const el = document.createElement('div');
        el.className = 'instrItem';
        el.innerHTML = `<strong>${i+1}. ${s.maneuver.instruction || s.name || ''}</strong><div style="color:var(--muted)">${Math.round(s.distance)} m • ${Math.round(s.duration)} s</div>`;
        instrList.appendChild(el);
      });
    } else {
      instrList.textContent = 'OSRM returnerade inga instruktioner.';
    }
  } catch (e){
    instrList.textContent = 'Fel vid hämtning av instruktioner: ' + e.message;
    console.error(e);
  }
});

/* SAVE BUTTON */
saveBtn.addEventListener('click', async () => {
  if (!currentPoints || currentPoints.length < 2) { 
    alert('Inspelad rutt måste ha minst två punkter'); 
    return; 
  }
  const name = routeNameInput.value.trim();
  if (!name) { alert('Sätt ett namn på rutten'); return; }
  await saveRouteToGitHub(name, currentPoints);
  await listSavedRoutes();
});

/* RESET PROGRESS */
resetProgressBtn.addEventListener('click', () => {
  if (!loadedRoutePath) { alert('Ladda en rutt först'); return; }
  if (!confirm('Resetta all progress för denna rutt?')) return;
  completedSegments = new Array(Math.max(0, (loadedRoute.points.length - 1))).fill(false);
  saveCompletedToStorage(loadedRoutePath, completedSegments);
  recomputeAndDrawSegments();
  firstFixEstablished = false;
  updateTrailer([]);
});

/* ROUTE SELECT REFRESH */
routeSelect.addEventListener('click', () => listSavedRoutes());

/* FOLLOW TOGGLE */
followBtn.addEventListener('click', () => {
  autoFollow = !autoFollow;
  followBtn.textContent = autoFollow ? 'Följ: På' : 'Följ: Av';
});

/* LIVE WATCH */
if ('geolocation' in navigator) {
  liveWatchId = navigator.geolocation.watchPosition(pos=>{
    const lat = pos.coords.latitude, lon = pos.coords.longitude;
    if (loadedRoute) handleLivePosition(lat, lon);
    if (autoFollow) map.easeTo({ center: [lon, lat], duration: 300 });
  }, err => {
    console.warn('Live watch error', err);
  }, { enableHighAccuracy:true, maximumAge:0, timeout:10000 });
}

setTimeout(() => listSavedRoutes(), 600);

window._gps = {
  saveRouteToGitHub, listSavedRoutes, loadRouteFromPath, recomputeAndDrawSegments
};
</script>
</body>
</html>
